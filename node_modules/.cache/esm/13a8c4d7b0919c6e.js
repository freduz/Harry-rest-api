let CustomErrorHandler,workSchedule,BlockApps,Joi;_b09‍.x([["default",()=>_b09‍.o]]);_b09‍.w("./../services/CustomeErrorHandler",[["default",["CustomErrorHandler"],function(v){CustomErrorHandler=v}]]);_b09‍.w("./../models/",[["workSchedule",["workSchedule"],function(v){workSchedule=v}],["BlockApps",["BlockApps"],function(v){BlockApps=v}]]);_b09‍.w("joi",[["default",["Joi"],function(v){Joi=v}]]);



const workController = {
  async addWorkTime(req, res, next) {
    const workSchema = Joi.object({
      days: Joi.array().required(),
    });

    const { error } = workSchema.validate(req.body);
    if (error) {
      return next(error);
    }

    try {
      const workDay = await workSchedule.exists({ day: req.body.day });

      if (workDay) {
        return next(
          CustomErrorHandler.alreadyExist("Work day is already scheduled")
        );
      }
    } catch (err) {
      return next(err);
    }

    const workData = new workSchedule({
      day: req.body.days,
      startTime: req.body.startTime,
      endTime: req.body.endTime,
    });

    try {
      const workDay = await workData.save();
      _b09‍.g.console.log(workDay);
      res.status(201).json({
        status: "work schedule created..",
        data: workDay,
      });
    } catch (err) {
      return next(err);
    }
  },

  async blockApp(req, res, next) {
    try {
      const appData = {
        workTime: req.body.workTime,
        nonWorkTime: req.body.nonWorkTime,
      };

      const updatedData = await workSchedule.findByIdAndUpdate(
        req.params.id,
        appData,
        {
          new: true,
          runValidators: true,
        }
      );

      res.status(200).json({
        status: "Apps block list generated",
        data: {
          updatedData,
        },
      });
    } catch (err) {
      return next(err);
    }
    // console.log(req.body);
  },
};

_b09‍.d(workController);
